function showExample() {
  const triggerInput = document.querySelector('#showExampleTriggerInput');
  const dropdownElem = document.querySelector('#showMethodExample');

  triggerInput.addEventListener('keydown', () => {
    dropdownElem.show();
  });
}

function hideExample() {
  const btn = document.querySelector('#hideExampleBtn');
  const dropdown = document.querySelector('#hideExample');

  btn.addEventListener('click', () => {
    dropdown.hide();
  });
}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2=globalThis,i$5=t$2.trustedTypes,s$2=i$5?i$5.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$4="$lit$",h$1=`lit$${Math.random().toFixed(9).slice(2)}$`,o$4="?"+h$1,n$3=`<${o$4}>`,r$3=document,l$2=()=>r$3.createComment(""),c$2=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a$2=Array.isArray,u$2=t=>a$2(t)||"function"==typeof t?.[Symbol.iterator],d$1="[ \t\n\f\r]",f$1=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,_=/>/g,m=RegExp(`>|${d$1}(?:([^\\s"'>=/]+)(${d$1}*=${d$1}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p$1=/'/g,g=/"/g,$=/^(?:script|style|textarea|title)$/i,y$1=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y$1(1),T=Symbol.for("lit-noChange"),E=Symbol.for("lit-nothing"),A=new WeakMap,C=r$3.createTreeWalker(r$3,129);function P(t,i){if(!a$2(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s$2?s$2.createHTML(i):i}const V=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":3===i?"<math>":"",c=f$1;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f$1?"!--"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m):void 0!==u[3]&&(c=m):c===m?">"===u[0]?(c=r??f$1,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'"'===u[3]?g:p$1):c===g||c===p$1?c=m:c===v||c===_?c=f$1:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith("/>")?" ":"";l+=c===f$1?s+n$3:d>=0?(o.push(a),s.slice(0,d)+e$4+s.slice(d)+h$1+x):s+h$1+(-2===d?i:x);}return [P(t,l+(t[s]||"<?>")+(2===i?"</svg>":3===i?"</math>":"")),o]};class N{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=V(t,s);if(this.el=N.createElement(f,n),C.currentNode=this.el.content,2===s||3===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes);}for(;null!==(r=C.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e$4)){const i=v[a++],s=r.getAttribute(t).split(h$1),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?H:"?"===e[1]?I:"@"===e[1]?L:k}),r.removeAttribute(t);}else t.startsWith(h$1)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h$1),s=t.length-1;if(s>0){r.textContent=i$5?i$5.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l$2()),C.nextNode(),d.push({type:2,index:++c});r.append(t[s],l$2());}}}else if(8===r.nodeType)if(r.data===o$4)d.push({type:2,index:c});else {let t=-1;for(;-1!==(t=r.data.indexOf(h$1,t+1));)d.push({type:7,index:c}),t+=h$1.length-1;}c++;}}static createElement(t,i){const s=r$3.createElement("template");return s.innerHTML=t,s}}function S$1(t,i,s=t,e){if(i===T)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c$2(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=S$1(t,h._$AS(t,i.values),h,e)),i}class M{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r$3).importNode(i,!0);C.currentNode=e;let h=C.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new R(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new z(h,this,t)),this._$AV.push(i),l=s[++n];}o!==l?.index&&(h=C.nextNode(),o++);}return C.currentNode=r$3,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class R{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=E,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0;}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=S$1(this,t,i),c$2(t)?t===E||null==t||""===t?(this._$AH!==E&&this._$AR(),this._$AH=E):t!==this._$AH&&t!==T&&this._(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):u$2(t)?this.k(t):this._(t);}O(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.O(t));}_(t){this._$AH!==E&&c$2(this._$AH)?this._$AA.nextSibling.data=t:this.T(r$3.createTextNode(t)),this._$AH=t;}$(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=N.createElement(P(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else {const t=new M(e,this),s=t.u(this.options);t.p(i),this.T(s),this._$AH=t;}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new N(t)),i}k(t){a$2(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new R(this.O(l$2()),this.O(l$2()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t));}}class k{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=E,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=E;}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=S$1(this,t,i,0),o=!c$2(t)||t!==this._$AH&&t!==T,o&&(this._$AH=t);else {const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=S$1(this,e[s+n],i,n),r===T&&(r=this._$AH[n]),o||=!c$2(r)||r!==this._$AH[n],r===E?t=E:t!==E&&(t+=(r??"")+h[n+1]),this._$AH[n]=r;}o&&!e&&this.j(t);}j(t){t===E?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"");}}class H extends k{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===E?void 0:t;}}class I extends k{constructor(){super(...arguments),this.type=4;}j(t){this.element.toggleAttribute(this.name,!!t&&t!==E);}}class L extends k{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5;}_$AI(t,i=this){if((t=S$1(this,t,i,0)??E)===T)return;const s=this._$AH,e=t===E&&s!==E||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==E&&(s===E||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t);}}class z{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){S$1(this,t);}}const j=t$2.litHtmlPolyfillSupport;j?.(N,R),(t$2.litHtmlVersions??=[]).push("3.2.1");const B=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new R(i.insertBefore(l$2(),t),t,void 0,s??{});}return h._$AI(t),h};

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const a$1=Symbol.for(""),o$3=t=>{if(t?.r===a$1)return t?._$litStatic$},s$1=t=>({_$litStatic$:t,r:a$1}),i$4=(t,...r)=>({_$litStatic$:r.reduce(((r,e,a)=>r+(t=>{if(void 0!==t._$litStatic$)return t._$litStatic$;throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t}. Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security.`)})(e)+t[a+1]),t[0]),r:a$1}),l$1=new Map,n$2=t=>(r,...e)=>{const a=e.length;let s,i;const n=[],u=[];let c,$=0,f=!1;for(;$<a;){for(c=r[$];$<a&&void 0!==(i=e[$],s=o$3(i));)c+=s+r[++$],f=!0;$!==a&&u.push(i),n.push(c),$++;}if($===a&&n.push(r[a]),f){const t=n.join("$$lit$$");void 0===(r=l$1.get(t))&&(n.raw=n,l$1.set(t,r=n)),e=u;}return t(r,...e)},u$1=n$2(x);

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1=globalThis,e$3=t$1.ShadowRoot&&(void 0===t$1.ShadyCSS||t$1.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s=Symbol(),o$2=new WeakMap;let n$1 = class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$3&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o$2.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o$2.set(s,t));}return t}toString(){return this.cssText}};const r$2=t=>new n$1("string"==typeof t?t:t+"",void 0,s),i$3=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[o+1]),t[0]);return new n$1(o,t,s)},S=(s,o)=>{if(e$3)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t$1.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o);}},c$1=e$3?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$2(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{is:i$2,defineProperty:e$2,getOwnPropertyDescriptor:r$1,getOwnPropertyNames:h,getOwnPropertySymbols:o$1,getPrototypeOf:n}=Object,a=globalThis,c=a.trustedTypes,l=c?c.emptyScript:"",p=a.reactiveElementPolyfillSupport,d=(t,s)=>t,u={toAttribute(t,s){switch(s){case Boolean:t=t?l:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t);}catch(t){i=null;}}return i}},f=(t,s)=>!i$2(t,s),y={attribute:!0,type:String,converter:u,reflect:!1,hasChanged:f};Symbol.metadata??=Symbol("metadata"),a.litPropertyMetadata??=new WeakMap;class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t);}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e$2(this.prototype,t,r);}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r$1(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t;}};return {get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y}static _$Ei(){if(this.hasOwnProperty(d("elementProperties")))return;const t=n(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties);}static finalize(){if(this.hasOwnProperty(d("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d("properties"))){const t=this.properties,s=[...h(t),...o$1(t)];for(const i of s)this.createProperty(i,t[i]);}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i);}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t);}this.elementStyles=this.finalizeStyles(this.styles);}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(c$1(s));}else void 0!==s&&i.push(c$1(s));return i}static _$Eu(t,s){const i=s.attribute;return !1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev();}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)));}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.();}removeController(t){this._$EO?.delete(t);}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t);}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((t=>t.hostConnected?.()));}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()));}attributeChangedCallback(t,s,i){this._$AK(t,i);}_$EC(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null;}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null;}}requestUpdate(t,s,i){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f)(this[t],s))return;this.P(t,s,i);}!1===this.isUpdatePending&&(this._$ES=this._$ET());}P(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t);}async _$ET(){this.isUpdatePending=!0;try{await this._$ES;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0;}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.P(s,this[s],i);}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EU();}catch(s){throw t=!1,this._$EU(),s}t&&this._$AE(s);}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return !0}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EC(t,this[t]))),this._$EU();}updated(t){}firstUpdated(t){}}b.elementStyles=[],b.shadowRootOptions={mode:"open"},b[d("elementProperties")]=new Map,b[d("finalized")]=new Map,p?.({ReactiveElement:b}),(a.reactiveElementVersions??=[]).push("2.0.4");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */class r extends b{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const s=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=B(s,this.renderRoot,this.renderOptions);}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0);}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1);}render(){return T}}r._$litElement$=!0,r["finalized"]=!0,globalThis.litElementHydrateSupport?.({LitElement:r});const i$1=globalThis.litElementPolyfillSupport;i$1?.({LitElement:r});(globalThis.litElementVersions??=[]).push("4.1.1");

// Copyright (c) Alaska Air. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.

// ---------------------------------------------------------------------

/* eslint-disable line-comment-position, no-inline-comments, no-confusing-arrow, no-nested-ternary, implicit-arrow-linebreak */

class AuroLibraryRuntimeUtils {

  /* eslint-disable jsdoc/require-param */

  /**
   * This will register a new custom element with the browser.
   * @param {String} name - The name of the custom element.
   * @param {Object} componentClass - The class to register as a custom element.
   * @returns {void}
   */
  registerComponent(name, componentClass) {
    if (!customElements.get(name)) {
      customElements.define(name, class extends componentClass {});
    }
  }

  /**
   * Finds and returns the closest HTML Element based on a selector.
   * @returns {void}
   */
  closestElement(
    selector, // selector like in .closest()
    base = this, // extra functionality to skip a parent
    __Closest = (el, found = el && el.closest(selector)) =>
      !el || el === document || el === window
        ? null // standard .closest() returns null for non-found selectors also
        : found
          ? found // found a selector INside this element
          : __Closest(el.getRootNode().host) // recursion!! break out to parent DOM
  ) {
    return __Closest(base);
  }
  /* eslint-enable jsdoc/require-param */

  /**
   * If the element passed is registered with a different tag name than what is passed in, the tag name is added as an attribute to the element.
   * @param {Object} elem - The element to check.
   * @param {String} tagName - The name of the Auro component to check for or add as an attribute.
   * @returns {void}
   */
  handleComponentTagRename(elem, tagName) {
    const tag = tagName.toLowerCase();
    const elemTag = elem.tagName.toLowerCase();

    if (elemTag !== tag) {
      elem.setAttribute(tag, true);
    }
  }

  /**
   * Validates if an element is a specific Auro component.
   * @param {Object} elem - The element to validate.
   * @param {String} tagName - The name of the Auro component to check against.
   * @returns {Boolean} - Returns true if the element is the specified Auro component.
   */
  elementMatch(elem, tagName) {
    const tag = tagName.toLowerCase();
    const elemTag = elem.tagName.toLowerCase();

    return elemTag === tag || elem.hasAttribute(tag);
  }
}

/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = ['top', 'right', 'bottom', 'left'];
const alignments = ['start', 'end'];
const placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'autoPlacement',
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));

      // Make `computeCoords` start from the right place.
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];

      // There are more placements to check.
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map(d => {
        const alignment = getAlignment(d.placement);
        return [d.placement, alignment && crossAxis ?
        // Check along the mainAxis and main crossAxis side.
        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :
        // Check only the mainAxis.
        d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,
      // Aligned placements should not check their opposite crossAxis
      // side.
      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$filter2;
                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis ||
                    // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === 'y';
                  }
                  return true;
                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset$1 = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

function hasWindow() {
  return typeof window !== 'undefined';
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [':popover-open', ':modal'].some(selector => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

function getCssDimensions(element) {
  const css = getComputedStyle(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}

// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}

function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :
  // RTL <body> scrollbar.
  getWindowScrollBarX(documentElement, htmlRect));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
      // Firefox with layout.scrollbar.side = 3 in about:config to test this.
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function isStaticPositioned(element) {
  return getComputedStyle(element).position === 'static';
}

function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;

  // Firefox returns the <html> element as the offsetParent if it's non-static,
  // while Chrome and Safari return the <body> element. The <body> element must
  // be used to perform the correct calculations even if the <html> element is
  // non-static.
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};

function isRTL(element) {
  return getComputedStyle(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          // If the reference is clipped, the ratio is 0. Throttle the refresh
          // to prevent an infinite loop of updates.
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = offset$1;

/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = autoPlacement$1;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = flip$1;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

/* eslint-disable line-comment-position, no-inline-comments */


class AuroFloatingUI {
  constructor() {
    // Store event listener references for cleanup
    this.focusHandler = null;
    this.clickHandler = null;
    this.keyDownHandler = null;
  }

  mirrorSize(fullscreen) {
    // mirror the boxsize from bibSizer
    const sizerStyle = window.getComputedStyle(this.element.bibSizer);
    const bibContent = this.element.bib.shadowRoot.querySelector(".container");
    if (fullscreen) {
      bibContent.style.width = '100dvw';
      bibContent.style.height = '100dvh';
      bibContent.style.maxWidth = 'none';
      bibContent.style.maxHeight = 'none';
    } else {
      if (sizerStyle.width !== '0px') bibContent.style.width = sizerStyle.width;
      if (sizerStyle.height !== '0px') bibContent.style.height = sizerStyle.height;
      bibContent.style.maxWidth = sizerStyle.maxWidth;
      bibContent.style.maxHeight = sizerStyle.maxHeight;
    }
  }

  position() {
    // fullscreen on mobileView 
    if (this.element.bib.mobileFullscreenBreakpoint) {
      const isMobile = window.matchMedia(`(max-width: ${this.element.bib.mobileFullscreenBreakpoint})`).matches;
      this.handleMobileFullscreen(isMobile);
      if (isMobile) {
        this.mirrorSize(true);
        return;
      }
    }
    this.mirrorSize(false);

    // Define the middlware for the floater configuration
    const middleware = [
      offset(this.element.floaterConfig.offset || 0),
    ];

    // Add flip middleware if flip is enabled
    if (this.element.floaterConfig.flip) {
      middleware.push(flip());
    }

    // Add autoPlacement middleware if autoPlacement is enabled
    if (this.element.floaterConfig.autoPlacement) {
      middleware.push(autoPlacement());
    }

    // Compute the position of the bib
    computePosition(this.element.trigger, this.element.bib, {
      placement: this.element.floaterConfig.placement || 'bottom',
      middleware: middleware || []
    }).then(({x, y}) => { // eslint-disable-line id-length
      Object.assign(this.element.bib.style, {
        left: `${x}px`,
        top: `${y}px`,
      });
    });
  }

  handleMobileFullscreen(isMobile) {
    if (isMobile) {
      this.element.bib.setAttribute('isFullscreen', "true");
      // reset the prev position
      this.element.bib.style.top = "0px";
      this.element.bib.style.left = "0px";
    } else {
      this.element.bib.removeAttribute('fullscreen');
    }
  }

  updateState() {
    const isVisible = this.element.isPopoverVisible;
    this.element.trigger.setAttribute('aria-expanded', isVisible);

    if (isVisible) {
      this.element.bib.setAttribute('data-show', true);
    } else {
      this.element.bib.removeAttribute('data-show');
    }

    if (!isVisible) {
      this.cleanupHideHandlers();
      try {
        this.element.cleanup?.();
      } catch (error) {
        // Do nothing
      }
    }
  }

  handleFocusLoss() {
    if (this.element.noHideOnThisFocusLoss || 
        this.element.hasAttribute('noHideOnThisFocusLoss')) {
      return;
    }

    const {activeElement} = document;
    if (activeElement === document.querySelector('body') ||
        this.element.contains(activeElement) ||
        this.element.bibContent?.contains(activeElement)) {
      return;
    }

    this.hideBib();
  }

  setupHideHandlers() {
    // Define handlers & store references
    this.focusHandler = () => this.handleFocusLoss();

    this.clickHandler = (evt) => {
      if (!evt.composedPath().includes(this.element.trigger) && 
          !evt.composedPath().includes(this.element.bibContent)) {
        this.hideBib();
      }
    };

    // ESC key handler
    this.keyDownHandler = (evt) => {
      if (evt.key === 'Escape' && this.element.isPopoverVisible) {
        this.hideBib();
      }
    };

    // Add event listeners using the stored references
    document.addEventListener('focusin', this.focusHandler);
    window.addEventListener('click', this.clickHandler);
    document.addEventListener('keydown', this.keyDownHandler);
  }

  cleanupHideHandlers() {
    // Remove event listeners if they exist
    if (this.focusHandler) {
      document.removeEventListener('focusin', this.focusHandler);
      this.focusHandler = null;
    }

    if (this.clickHandler) {
      window.removeEventListener('click', this.clickHandler);
      this.clickHandler = null;
    }

    if (this.keyDownHandler) {
      document.removeEventListener('keydown', this.keyDownHandler);
      this.keyDownHandler = null;
    }
  }

  handleUpdate(changedProperties) {
    if (changedProperties.has('isPopoverVisible')) {
      this.updateState();
    }
  }

  updateCurrentExpandedDropdown() {
    // Close any other dropdown that is already open
    if (document.expandedAuroDropdown) {
      this.hideBib(document.expandedAuroDropdown);
    }

    document.expandedAuroDropdown = this;
  }

  showBib() {
    if (!this.element.disabled && !this.element.isPopoverVisible) {
      this.updateCurrentExpandedDropdown();
      this.element.isPopoverVisible = true;
      this.element.triggerChevron?.setAttribute('data-expanded', true);
      this.dispatchEventDropdownToggle();
      this.position();
      
      // Clean up any existing handlers before setting up new ones
      this.cleanupHideHandlers();
      this.setupHideHandlers();

      // Setup auto update to handle resize and scroll
      this.element.cleanup = autoUpdate(this.element.trigger, this.element.bib, () => {
        this.position();
      });
    }
  }

  hideBib() {
    if (this.element.isPopoverVisible && !this.element.disabled && !this.element.noToggle) {
      this.element.isPopoverVisible = false;
      this.element.triggerChevron?.removeAttribute('data-expanded');
      this.dispatchEventDropdownToggle();
    }
  }

  /**
   * @private
   * @returns {void} Dispatches event with an object showing the state of the dropdown.
   */
  dispatchEventDropdownToggle() {
    const event = new CustomEvent('auroDropdown-toggled', {
      detail: {
        expanded: this.isPopoverVisible,
      },
      composed: true
    });

    this.element.dispatchEvent(event);
  }

  handleClick() {
    if (this.element.isPopoverVisible) {
      this.hideBib();
    } else {
      this.showBib();
    }

    const event = new CustomEvent('auroDropdown-triggerClick', {
      composed: true,
      details: {
        expanded: this.element.isPopoverVisible
      }
    });

    this.element.dispatchEvent(event);
  }

  handleEvent(event) {
    if (!this.element.disableEventShow) {
      switch (event.type) {
        case 'keydown':
          // Support both Enter and Space keys for accessibility
          // Space is included as it's expected behavior for interactive elements
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault(); // Prevent page scroll on space
            this.handleClick();
          }
          break;
        case 'mouseenter':
          if (this.element.hoverToggle) {
            this.showBib();
          }
          break;
        case 'mouseleave':
          if (this.element.hoverToggle) {
            this.hideBib();
          }
          break;
        case 'focus':
          if (this.element.focusShow) {
            /*
              This needs to better handle clicking that gives focus - 
              currently it shows and then immediately hides the bib 
            */
            this.showBib();
          }
          break;
        case 'blur':
          this.handleFocusLoss();
          break;
        case 'click':
          this.handleClick();
          break;
          // Do nothing
      }
    }
  }

  handleTriggerTabIndex() {
    const focusableElementSelectors = [
      'a',
      'button',
      'input:not([type="hidden"])',
      'select',
      'textarea',
      '[tabindex]:not([tabindex="-1"])',
      'auro-button',
      'auro-input',
      'auro-hyperlink'
    ];

    const triggerNode = this.element.querySelectorAll('[slot="trigger"]')[0];
    const triggerNodeTagName = triggerNode.tagName.toLowerCase();

    focusableElementSelectors.forEach((selector) => {
      // Check if the trigger node element is focusable
      if (triggerNodeTagName === selector) {
        this.element.tabIndex = -1;
        return;
      }

      // Check if any child is focusable
      if (triggerNode.querySelector(selector)) {
        this.element.tabIndex = -1;
      }
    });
  }

  configure(elem) {
    this.element = elem;
    this.element.trigger = this.element.shadowRoot.querySelector('#trigger');
    this.element.triggerChevron = this.element.shadowRoot.querySelector('#showStateIcon');
    this.element.bib = this.element.shadowRoot.querySelector('#bib');
    this.element.bibSizer = this.element.shadowRoot.querySelector('#bibSizer');
    
    document.body.append(this.element.bib);

    this.handleTriggerTabIndex();

    this.element.trigger.addEventListener('keydown', (event) => this.handleEvent(event));
    this.element.trigger.addEventListener('click', (event) => this.handleEvent(event));
    this.element.trigger.addEventListener('mouseenter', (event) => this.handleEvent(event));
    this.element.trigger.addEventListener('mouseleave', (event) => this.handleEvent(event));
    this.element.trigger.addEventListener('focus', (event) => this.handleEvent(event));
    this.element.trigger.addEventListener('blur', (event) => this.handleEvent(event));
  }

  disconnect() {
    this.cleanupHideHandlers();
    this.element.cleanup?.();
    
    // Remove event & keyboard listeners
    if (this.element?.trigger) {
      this.element.trigger.removeEventListener('keydown', (event) => this.handleEvent(event));
      this.element.trigger.removeEventListener('click', (event) => this.handleEvent(event));
      this.element.trigger.removeEventListener('mouseenter', (event) => this.handleEvent(event));
      this.element.trigger.removeEventListener('mouseleave', (event) => this.handleEvent(event));
      this.element.trigger.removeEventListener('focus', (event) => this.handleEvent(event));
      this.element.trigger.removeEventListener('blur', (event) => this.handleEvent(event));
    }
  }
}

// Copyright (c) Alaska Air. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


class AuroDependencyVersioning {

  /**
   * Generates a unique string to be used for child auro element naming.
   * @private
   * @param {string} baseName - Defines the first part of the unique element name.
   * @param {string} version - Version of the component that will be appended to the baseName.
   * @returns {string} - Unique string to be used for naming.
   */
  generateElementName(baseName, version) {
    let result = baseName;

    result += '-';
    result += version.replace(/[.]/g, '_');

    return result;
  }

  /**
   * Generates a unique string to be used for child auro element naming.
   * @param {string} baseName - Defines the first part of the unique element name.
   * @param {string} version - Version of the component that will be appended to the baseName.
   * @returns {string} - Unique string to be used for naming.
   */
  generateTag(baseName, version, tagClass) {
    const elementName = this.generateElementName(baseName, version);
    const tag = i$4`${s$1(elementName)}`;

    if (!customElements.get(elementName)) {
      customElements.define(elementName, class extends tagClass {});
    }

    return tag;
  }
}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$1=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const e=e$1(class extends i{constructor(t$1){if(super(t$1),t$1.type!==t.ATTRIBUTE||"class"!==t$1.name||t$1.strings?.length>2)throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")}render(t){return " "+Object.keys(t).filter((s=>t[s])).join(" ")+" "}update(s,[i]){if(void 0===this.st){this.st=new Set,void 0!==s.strings&&(this.nt=new Set(s.strings.join(" ").split(/\s/).filter((t=>""!==t))));for(const t in i)i[t]&&!this.nt?.has(t)&&this.st.add(t);return this.render(i)}const r=s.element.classList;for(const t of this.st)t in i||(r.remove(t),this.st.delete(t));for(const t in i){const s=!!i[t];s===this.st.has(t)||this.nt?.has(t)||(s?(r.add(t),this.st.add(t)):(r.remove(t),this.st.delete(t)));}return T}});

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const o=o=>o??E;

// Copyright (c) 2020 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


/**
 * @attr {Boolean} hidden - If present, the component will be hidden both visually and from screen readers
 * @attr {Boolean} hiddenVisually - If present, the component will be hidden visually, but still read by screen readers
 * @attr {Boolean} hiddenAudible - If present, the component will be hidden from screen readers, but seen visually
 */

class AuroElement extends r {

  // function to define props used within the scope of this component
  static get properties() {
    return {
      hidden:         { type: Boolean,
                        reflect: true },
      hiddenVisually: { type: Boolean,
                        reflect: true },
      hiddenAudible:  { type: Boolean,
                        reflect: true },
    };
  }

  /**
   * @private Function that determines state of aria-hidden
   */
  hideAudible(value) {
    if (value) {
      return 'true'
    }

    return 'false'
  }
}

var error = {"role":"img","color":"currentColor","title":"","desc":"Error alert indicator.","width":"var(--auro-size-lg, var(--ds-size-300, 1.5rem))","height":"var(--auro-size-lg, var(--ds-size-300, 1.5rem))","xmlns":"http://www.w3.org/2000/svg","xmlns_xlink":"http://www.w3.org/1999/xlink","viewBox":"0 0 24 24","path":"/icons","style":"ico_squareLarge","type":"icon","name":"error","category":"alert","deprecated":true,"svg":"<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" aria-labelledby=\"error__desc\" class=\"ico_squareLarge\" data-deprecated=\"true\" role=\"img\" style=\"min-width:var(--auro-size-lg, var(--ds-size-300, 1.5rem));height:var(--auro-size-lg, var(--ds-size-300, 1.5rem));fill:currentColor\" viewBox=\"0 0 24 24\" part=\"svg\"><title/><desc id=\"error__desc\">Error alert indicator.</desc><path d=\"m13.047 5.599 6.786 11.586A1.207 1.207 0 0 1 18.786 19H5.214a1.207 1.207 0 0 1-1.047-1.815l6.786-11.586a1.214 1.214 0 0 1 2.094 0m-1.165.87a.23.23 0 0 0-.085.085L5.419 17.442a.232.232 0 0 0 .203.35h12.756a.234.234 0 0 0 .203-.35L12.203 6.554a.236.236 0 0 0-.321-.084M12 15.5a.75.75 0 1 1 0 1.5.75.75 0 0 1 0-1.5m-.024-6.22c.325 0 .589.261.589.583v4.434a.586.586 0 0 1-.589.583.586.586 0 0 1-.588-.583V9.863c0-.322.264-.583.588-.583\"/></svg>"};

/* eslint-disable no-underscore-dangle, jsdoc/no-undefined-types, jsdoc/require-param-description */

const _fetchMap = new Map();

/**
 * A callback to parse Response body.
 *
 * @callback ResponseParser
 * @param {Fetch.Response} response
 * @returns {Promise}
 */

/**
 * A minimal in-memory map to de-duplicate Fetch API media requests.
 *
 * @param {String} uri
 * @param {Object} [options={}]
 * @param {ResponseParser} [options.responseParser=(response) => response.text()]
 * @returns {Promise}
 */
const cacheFetch = (uri, options = {}) => {
  const responseParser = options.responseParser || ((response) => response.text());
  if (!_fetchMap.has(uri)) {
    _fetchMap.set(uri, fetch(uri).then(responseParser));
  }
  return _fetchMap.get(uri);
};

var styleCss$2 = i$3`*,*:before,*:after{box-sizing:border-box}@media(prefers-reduced-motion: reduce){*,*:before,*:after{animation-duration:.01ms !important;animation-iteration-count:1 !important;transition-duration:.01ms !important}}*:focus-visible{outline:0}*:focus-visible{outline:0}:focus:not(:focus-visible){outline:3px solid transparent}.util_displayInline{display:inline}.util_displayInlineBlock{display:inline-block}.util_displayBlock,:host{display:block}.util_displayFlex{display:flex}.util_displayHidden,:host([hidden]:not(:focus):not(:active)){display:none}.util_displayHiddenVisually,:host([hiddenVisually]:not(:focus):not(:active)){position:absolute;overflow:hidden;clip:rect(1px, 1px, 1px, 1px);width:1px;height:1px;padding:0;border:0}.ico_squareLarge{fill:currentColor;height:var(--auro-size-lg, var(--ds-size-300, 1.5rem))}.ico_squareSmall{fill:currentColor;height:.6rem}.ico_squareMed{fill:currentColor;height:var(--auro-size-md, var(--ds-size-200, 1rem))}.ico_squareSml{fill:currentColor;height:var(--auro-size-sm, var(--ds-size-150, 0.75rem))}:host{color:currentColor;vertical-align:middle;line-height:1;display:inline-block}:host .logo{color:var(--ds-color-brand-midnight-400, #01426a)}:host([customSize]){--auro-size-lg:100%;--ds-size-300: 100%;width:100%;height:100%}.label{display:flex;align-items:flex-start}.label svg{margin:0 var(--ds-size-50, 0.25rem)}.labelContainer{line-height:1.8}`;

// Copyright (c) 2020 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


// See https://git.io/JJ6SJ for "How to document your components using JSDoc"
/**
 * @attr {Boolean} onDark - Set value for on-dark version of auro-icon
 * @slot - Hidden from visibility, used for a11y if icon description is needed
 */

// build the component class
class BaseIcon extends AuroElement {
  constructor() {
    super();
    this.onDark = false;
  }

  // function to define props used within the scope of this component
  static get properties() {
    return {
      ...super.properties,
      onDark: {
        type: Boolean,
        reflect: true
      },

      /**
       * @private
       */
      svg: {
        attribute: false,
        reflect: true
      }
    };
  }

  static get styles() {
    return i$3`
      ${styleCss$2}
    `;
  }

  /**
   * Async function to fetch requested icon from npm CDN.
   * @private
   * @param {string} category - Icon category.
   * @param {string} name - Icon name.
   * @returns {SVGElement} DOM - Ready HTML to be appended.
   */
  async fetchIcon(category, name) {
    let iconHTML = '';

    if (category === 'logos') {
      iconHTML = await cacheFetch(`${this.uri}/${category}/${name}.svg`);
    } else {
      iconHTML = await cacheFetch(`${this.uri}/icons/${category}/${name}.svg`);
    }

    const dom = new DOMParser().parseFromString(iconHTML, 'text/html');

    return dom.body.querySelector('svg');
  }

  // lifecycle function
  async firstUpdated() {
    if (!this.customSvg) {
      const svg = await this.fetchIcon(this.category, this.name);

      if (svg) {
        this.svg = svg;
      } else if (!svg) {
        const penDOM = new DOMParser().parseFromString(error.svg, 'text/html');

        this.svg = penDOM.body.firstChild;
      }
    }
  }
}

var tokensCss$1 = i$3`:host{--ds-auro-icon-color: var(--ds-color-icon-primary-default, $ds-color-icon-primary-default)}`;

var colorCss$2 = i$3`:host{color:var(--ds-auro-icon-color)}:host([customColor]){color:inherit}:host(:not([onDark])[accent]){--ds-auro-icon-color: var(--ds-color-icon-accent-default, #a2c270)}:host(:not([onDark])[disabled]){--ds-auro-icon-color: var(--ds-color-icon-ui-primary-disabled-default, #adadad)}:host(:not([onDark])[emphasis]){--ds-auro-icon-color: var(--ds-color-icon-emphasis-default, #2a2a2a)}:host(:not([onDark])[error]){--ds-auro-icon-color: var(--ds-color-icon-error-default, #cc1816)}:host(:not([onDark])[info]){--ds-auro-icon-color: var(--ds-color-icon-info-default, #326aa5)}:host(:not([onDark])[secondary]){--ds-auro-icon-color: var(--ds-color-icon-secondary-default, #7e8894)}:host(:not([onDark])[subtle]){--ds-auro-icon-color: var(--ds-color-icon-subtle-default, #a0c9f1)}:host(:not([onDark])[success]){--ds-auro-icon-color: var(--ds-color-icon-success-default, #40a080)}:host(:not([onDark])[tertiary]){--ds-auro-icon-color: var(--ds-color-icon-tertiary-default, #afb9c6)}:host(:not([onDark])[warning]){--ds-auro-icon-color: var(--ds-color-icon-warning-default, #c49432)}:host([onDark]){--ds-auro-icon-color: var(--ds-color-icon-primary-inverse, #f7f7f7)}:host([onDark][accent]){--ds-auro-icon-color: var(--ds-color-icon-accent-inverse, #badd81)}:host([onDark][disabled]){--ds-auro-icon-color: var(--ds-color-icon-ui-primary-disabled-inverse, #7e7e7e)}:host([onDark][emphasis]){--ds-auro-icon-color: var(--ds-color-icon-emphasis-inverse, #ffffff)}:host([onDark][error]){--ds-auro-icon-color: var(--ds-color-icon-error-inverse, #f9aca6)}:host([onDark][info]){--ds-auro-icon-color: var(--ds-color-icon-info-inverse, #89b2d4)}:host([onDark][secondary]){--ds-auro-icon-color: var(--ds-color-icon-secondary-inverse, #ccd2db)}:host([onDark][subtle]){--ds-auro-icon-color: var(--ds-color-icon-subtle-inverse, #326aa5)}:host([onDark][success]){--ds-auro-icon-color: var(--ds-color-icon-success-inverse, #8eceb9)}:host([onDark][tertiary]){--ds-auro-icon-color: var(--ds-color-icon-tertiary-inverse, #939fad)}:host([onDark][warning]){--ds-auro-icon-color: var(--ds-color-icon-warning-inverse, #f2c153)}`;

// Copyright (c) 2020 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


// See https://git.io/JJ6SJ for "How to document your components using JSDoc"
/**
 * auro-icon provides users a way to use the Auro Icons by simply passing in the category and name.
 *
 * @attr {Boolean} customSize - Allows for custom size use.
 * @attr {String} category - The category of the icon you are looking for. See https://auro.alaskaair.com/icons/usage.
 * @attr {String} name - The name of the icon you are looking for without the file extension. See https://auro.alaskaair.com/icons/usage
 * @attr {Boolean} customColor - Removes primary selector.
 * @attr {Boolean} customSvg - When true, auro-icon will render a custom SVG inside the default slot.
 * @attr {Boolean} label - Exposes content in slot as icon label.
 * @attr {Boolean} primary - DEPRECATED: Sets the icon to use the baseline primary icon style.
 * @attr {Boolean} accent - Sets the icon to use the accent style.
 * @attr {Boolean} emphasis - Sets the icon to use the emphasis style.
 * @attr {Boolean} disabled - Sets the icon to use the disabled style.
 * @attr {Boolean} error - Sets the icon to use the error style.
 * @attr {Boolean} info - Sets the icon to use the info style.
 * @attr {Boolean} secondary - Sets the icon to use the secondary style.
 * @attr {Boolean} tertiary - Sets the icon to use the tertiary style.
 * @attr {Boolean} subtle - Sets the icon to use the subtle style.
 * @attr {Boolean} success - Sets the icon to use the success style.
 * @attr {Boolean} warning - Sets the icon to use the warning style.
 * @attr {String} ariaHidden - Set aria-hidden value. Default is `true`. Option is `false`.
 * @attr {String} uri - Set the uri for CDN used when fetching icons
 * @slot - Hidden from visibility, used for a11y if icon description is needed.
 * @slot svg - Used for custom SVG content.
 */

// build the component class
class AuroIcon extends BaseIcon {
  constructor() {
    super();

    this.uri = 'https://cdn.jsdelivr.net/npm/@alaskaairux/icons@latest/dist';

    this.privateDefaults();
  }

  /**
   * Internal Defaults.
   * @private
   * @returns {void}
   */
  privateDefaults() {
    this.accent = false;
    this.customColor = false;
    this.customSvg = false;
    this.disabled = false;
    this.emphasis = false;
    this.error = false;
    this.info = false;
    this.label = false;
    this.primary = false;
    this.secondary = false;
    this.subtle = false;
    this.success = false;
    this.tertiary = false;
    this.warning = false;
    this.runtimeUtils = new AuroLibraryRuntimeUtils();
  }

  // function to define props used within the scope of this component
  static get properties() {
    return {
      ...super.properties,
      accent: {
        type: Boolean,
        reflect: true
      },
      ariaHidden: {
        type: String,
        reflect: true
      },
      category: {
        type: String,
        reflect: true
      },
      customColor: {
        type: Boolean
      },
      customSvg: {
        type: Boolean
      },
      disabled: {
        type: Boolean,
        reflect: true
      },
      emphasis: {
        type: Boolean,
        reflect: true
      },
      error: {
        type: Boolean,
        reflect: true
      },
      info: {
        type: Boolean,
        reflect: true
      },
      label: {
        type: Boolean,
        reflect: true
      },
      name: {
        type: String,
        reflect: true
      },
      primary: {
        type: Boolean,
        reflect: true
      },
      secondary: {
        type: Boolean,
        reflect: true
      },
      subtle: {
        type: Boolean,
        reflect: true
      },
      success: {
        type: Boolean,
        reflect: true
      },
      tertiary: {
        type: Boolean,
        reflect: true
      },
      uri: {
        type: String
      },
      warning: {
        type: Boolean,
        reflect: true
      }
    };
  }

  static get styles() {
    return [
      super.styles,
      i$3`${tokensCss$1}`,
      i$3`${styleCss$2}`,
      i$3`${colorCss$2}`
    ];
  }

  connectedCallback() {
    super.connectedCallback();

    // Add the tag name as an attribute if it is different than the component name
    this.runtimeUtils.handleComponentTagRename(this, 'auro-icon');
  }

  // function that renders the HTML and CSS into  the scope of the component
  render() {
    const a11y = {
      'labelContainer': true,
      'util_displayHiddenVisually': !this.label
    };

    const classes = {
      'label': this.label
    };

    return x`
      <div
        class="${e(classes)}"
        title="${o(this.title || undefined)}">
        <span aria-hidden="${o(this.ariaHidden ? this.ariaHidden : true)}" part="svg">
          ${this.customSvg ? x`
              <slot name="svg"></slot>
            ` : x`
              ${this.svg}
            `
          }
        </span>

        <div class="${e(a11y)}">
          <slot></slot>
        </div>
      </div>
    `;
  }
}

// default internal definition
if (!customElements.get("auro-icon")) {
  customElements.define("auro-icon", AuroIcon);
}

var iconVersion = '6.1.1';

var styleCss$1 = i$3`:host{position:relative}.label{font-size:var(--ds-text-body-size-xs, 0.75rem);line-height:var(--ds-text-body-size-default, 1rem);white-space:normal}.trigger{position:relative;display:flex;align-items:center;border-width:1px;border-style:solid}@media(hover: hover){.trigger:hover{cursor:pointer}}.triggerContentWrapper{overflow:hidden;flex:1;text-overflow:ellipsis;white-space:nowrap}#showStateIcon{display:flex;height:100%;align-items:center;margin-left:var(--ds-size-100, 0.5rem)}#showStateIcon [auro-icon]{height:var(--ds-size-300, 1.5rem);line-height:var(--ds-size-300, 1.5rem)}#showStateIcon[data-expanded=true] [auro-icon]{transform:rotate(-180deg)}.helpText{margin-top:var(--ds-size-50, 0.25rem);font-size:var(--ds-text-body-size-xs, 0.75rem);line-height:var(--ds-text-body-size-default, 1rem)}:host([disabled]){pointer-events:none}:host([inset]) .trigger{padding:var(--ds-size-150, 0.75rem) var(--ds-size-200, 1rem)}:host([common]) .trigger,:host([inset][bordered]) .trigger{padding:var(--ds-size-200, 1rem) var(--ds-size-150, 0.75rem)}:host([common]) .trigger,:host([rounded]) .trigger{border-radius:var(--ds-border-radius, 0.375rem)}`;

var colorCss$1 = i$3`.label{color:var(--ds-auro-dropdown-label-text-color)}.trigger{border-color:var(--ds-auro-dropdown-trigger-border-color);background-color:var(--ds-auro-dropdown-trigger-container-color);color:var(--ds-auro-dropdown-trigger-text-color)}.trigger:focus-within,.trigger:active{--ds-auro-dropdown-trigger-border-color: var(--ds-color-border-active-default, #0074c8)}.trigger:focus-within:not(:active){--ds-auro-dropdown-trigger-border-color: var(--ds-color-border-ui-focus-default, #2c67b5);box-shadow:inset 0 0 0 1px var(--ds-color-border-ui-focus-default, #2c67b5)}.trigger:hover{--ds-auro-dropdown-trigger-container-color: var(--ds-color-container-ui-secondary-hover-default, rgba(0, 0, 0, 0.03))}.helpText{color:var(--ds-auro-dropdown-help-text-color)}:host([disabled]){--ds-auro-dropdown-trigger-text-color: var(--ds-color-text-ui-disabled-default, #adadad);--ds-auro-dropdown-label-text-color: var(--ds-color-text-ui-disabled-default, #adadad)}:host([common]),:host([bordered]){--ds-auro-dropdown-trigger-border-color: var(--ds-color-border-primary-default, #585e67)}:host([common]) .trigger:active,:host([common]) .trigger:focus-within,:host([bordered]) .trigger:active,:host([bordered]) .trigger:focus-within{--ds-auro-dropdown-trigger-border-color: var(--ds-color-border-ui-focus-default, #2c67b5)}:host([error]){--ds-auro-dropdown-help-text-color: var(--ds-color-text-error-default, #cc1816);--ds-auro-dropdown-trigger-border-color: var(--ds-color-border-error-default, #cc1816)}:host([error]) .trigger{box-shadow:inset 0 0 0 1px var(--ds-auro-dropdown-trigger-border-color)}:host([error]) .trigger:focus-within{--ds-auro-dropdown-trigger-border-color: var(--ds-color-border-ui-focus-default, #2c67b5);box-shadow:none}:host([error]) .trigger:active{--ds-auro-dropdown-trigger-border-color: var(--ds-color-border-ui-focus-default, #2c67b5);box-shadow:inset 0 0 0 1px var(--ds-auro-dropdown-trigger-border-color)}:host([disabled][common]),:host([disabled][bordered]){--ds-auro-dropdown-trigger-border-color: var(--ds-color-border-ui-disabled-default, #adadad)}`;

var tokensCss = i$3`:host{--ds-auro-dropdown-help-text-color: var(--ds-color-text-secondary-default, #525252);--ds-auro-dropdown-label-text-color: var(--ds-color-text-secondary-default, #525252);--ds-auro-dropdown-popover-container-color: var(--ds-color-container-primary-default, #ffffff);--ds-auro-dropdown-popover-border-color: transparent;--ds-auro-dropdown-popover-text-color: var(--ds-color-text-primary-default, #2a2a2a);--ds-auro-dropdown-trigger-container-color: var(--ds-color-container-primary-default, #ffffff);--ds-auro-dropdown-trigger-border-color: transparent;--ds-auro-dropdown-trigger-text-color: var(--ds-color-text-primary-default, #2a2a2a);--ds-auro-dropdownbib-boxshadow-color: var(--ds-elevation-200, 0px 0px 10px rgba(0, 0, 0, 0.15));--ds-auro-dropdownbib-container-color: var(--ds-color-container-primary-default, #ffffff);--ds-auro-dropdownbib-text-color: var(--ds-color-text-primary-default, #2a2a2a)}`;

var dsVariableFlat = {
	"ds-asset-font-circular-family-name": "AS Circular",
	"ds-asset-font-circular-filename": "ASCircularWeb",
	"ds-asset-font-circular-weight-light": "-Light",
	"ds-asset-font-circular-weight-medium": "-Medium",
	"ds-asset-font-circular-weight-book": "-Book",
	"ds-border-radius": "0.375rem",
	"ds-size-25": "0.125rem",
	"ds-size-50": "0.25rem",
	"ds-size-75": "0.375rem",
	"ds-size-100": "0.5rem",
	"ds-size-150": "0.75rem",
	"ds-size-200": "1rem",
	"ds-size-300": "1.5rem",
	"ds-size-400": "2rem",
	"ds-size-500": "2.5rem",
	"ds-size-600": "3rem",
	"ds-size-700": "3.5rem",
	"ds-size-800": "4rem",
	"ds-size-900": "4.5rem",
	"ds-size-1000": "5rem",
	"ds-unitless-scale-20": 0.25,
	"ds-unitless-scale-50": 0.5,
	"ds-unitless-scale-100": 1,
	"ds-unitless-scale-140": 1.4,
	"ds-unitless-scale-150": 1.5,
	"ds-unitless-scale-200": 2,
	"ds-unitless-scale-300": 3,
	"ds-unitless-scale-350": 3.5,
	"ds-animation-default-property": "all",
	"ds-animation-default-duration": "0.3s",
	"ds-animation-default-timing": "ease-out",
	"ds-depth-overlay": "200",
	"ds-depth-modal": "400",
	"ds-depth-tooltip": "300",
	"ds-elevation-100": "0px 0px 5px rgba(0, 0, 0, 0.15)",
	"ds-elevation-200": "0px 0px 10px rgba(0, 0, 0, 0.15)",
	"ds-elevation-300": "0px 0px 15px rgba(0, 0, 0, 0.2)",
	"ds-grid-breakpoint-xs": "320px",
	"ds-grid-breakpoint-sm": "576px",
	"ds-grid-breakpoint-md": "768px",
	"ds-grid-breakpoint-lg": "1024px",
	"ds-grid-breakpoint-xl": "1232px",
	"ds-grid-column-xs": "6",
	"ds-grid-column-sm": "12",
	"ds-grid-column-md": "12",
	"ds-grid-column-lg": "12",
	"ds-grid-column-xl": "12",
	"ds-grid-gutter-xs": "0.5rem",
	"ds-grid-gutter-sm": "1rem",
	"ds-grid-gutter-md": "1.5rem",
	"ds-grid-gutter-lg": "1.5rem",
	"ds-grid-gutter-xl": "2rem",
	"ds-grid-margin-xs": "1rem",
	"ds-grid-margin-sm": "1rem",
	"ds-grid-margin-md": "1.5rem",
	"ds-grid-margin-lg": "2rem",
	"ds-grid-margin-xl": "2rem",
	"ds-font-family-default": "'AS Circular', Helvetica Neue, Arial, sans-serif",
	"ds-font-family-mono": "Menlo, Monaco, Consolas, 'Courier New', monospace",
	"ds-text-heading-300-weight": "300",
	"ds-text-heading-300-px": "18px",
	"ds-text-heading-300-size": "1.125rem",
	"ds-text-heading-300-height": "1.625rem",
	"ds-text-heading-300-height-px": "26px",
	"ds-text-heading-400-weight": "300",
	"ds-text-heading-400-px": "20px",
	"ds-text-heading-400-size": "1.25rem",
	"ds-text-heading-400-height": "1.625rem",
	"ds-text-heading-400-height-px": "26px",
	"ds-text-heading-500-weight": "300",
	"ds-text-heading-500-px-breakpoint-sm": "22px",
	"ds-text-heading-500-px-breakpoint-md": "24px",
	"ds-text-heading-500-px-breakpoint-lg": "24px",
	"ds-text-heading-500-size-breakpoint-sm": "1.375rem",
	"ds-text-heading-500-size-breakpoint-md": "1.5rem",
	"ds-text-heading-500-size-breakpoint-lg": "1.5rem",
	"ds-text-heading-500-height-breakpoint-sm": "1.625rem",
	"ds-text-heading-500-height-breakpoint-px-sm": "26px",
	"ds-text-heading-500-height-breakpoint-md": "1.875rem",
	"ds-text-heading-500-height-breakpoint-px-md": "30px",
	"ds-text-heading-500-height-breakpoint-lg": "2rem",
	"ds-text-heading-500-height-breakpoint-px-lg": "32px",
	"ds-text-heading-600-weight": "300",
	"ds-text-heading-600-px-breakpoint-sm": "26px",
	"ds-text-heading-600-px-breakpoint-md": "28px",
	"ds-text-heading-600-px-breakpoint-lg": "28px",
	"ds-text-heading-600-size-breakpoint-sm": "1.625rem",
	"ds-text-heading-600-size-breakpoint-md": "1.75rem",
	"ds-text-heading-600-size-breakpoint-lg": "1.75rem",
	"ds-text-heading-600-height-breakpoint-sm": "1.875rem",
	"ds-text-heading-600-height-breakpoint-px-sm": "30px",
	"ds-text-heading-600-height-breakpoint-md": "2.125rem",
	"ds-text-heading-600-height-breakpoint-px-md": "34px",
	"ds-text-heading-600-height-breakpoint-lg": "2.25rem",
	"ds-text-heading-600-height-breakpoint-px-lg": "36px",
	"ds-text-heading-700-weight": "500",
	"ds-text-heading-700-px-breakpoint-sm": "28px",
	"ds-text-heading-700-px-breakpoint-md": "32px",
	"ds-text-heading-700-px-breakpoint-lg": "36px",
	"ds-text-heading-700-size-breakpoint-sm": "1.75rem",
	"ds-text-heading-700-size-breakpoint-md": "2rem",
	"ds-text-heading-700-size-breakpoint-lg": "2.25rem",
	"ds-text-heading-700-height-breakpoint-sm": "2.125rem",
	"ds-text-heading-700-height-breakpoint-px-sm": "34px",
	"ds-text-heading-700-height-breakpoint-md": "2.375rem",
	"ds-text-heading-700-height-breakpoint-px-md": "38px",
	"ds-text-heading-700-height-breakpoint-lg": "2.75rem",
	"ds-text-heading-700-height-breakpoint-px-lg": "44px",
	"ds-text-heading-800-weight": "500",
	"ds-text-heading-800-px-breakpoint-sm": "32px",
	"ds-text-heading-800-px-breakpoint-md": "36px",
	"ds-text-heading-800-px-breakpoint-lg": "40px",
	"ds-text-heading-800-size-breakpoint-sm": "2rem",
	"ds-text-heading-800-size-breakpoint-md": "2.25rem",
	"ds-text-heading-800-size-breakpoint-lg": "2.5rem",
	"ds-text-heading-800-height-breakpoint-sm": "2.375rem",
	"ds-text-heading-800-height-breakpoint-px-sm": "38px",
	"ds-text-heading-800-height-breakpoint-md": "2.625rem",
	"ds-text-heading-800-height-breakpoint-px-md": "42px",
	"ds-text-heading-800-height-breakpoint-lg": "3rem",
	"ds-text-heading-800-height-breakpoint-px-lg": "48px",
	"ds-text-heading-default-weight": "500",
	"ds-text-heading-default-margin": "0",
	"ds-text-heading-default-spacing": "-0.2px",
	"ds-text-heading-medium-weight": "300",
	"ds-text-heading-display-weight": "100",
	"ds-text-heading-display-px-breakpoint-sm": "44px",
	"ds-text-heading-display-px-breakpoint-md": "48px",
	"ds-text-heading-display-px-breakpoint-lg": "56px",
	"ds-text-heading-display-size-breakpoint-sm": "2.75rem",
	"ds-text-heading-display-size-breakpoint-md": "3rem",
	"ds-text-heading-display-size-breakpoint-lg": "3.5rem",
	"ds-text-heading-display-height-breakpoint-sm": "3.375rem",
	"ds-text-heading-display-height-breakpoint-px-sm": "54px",
	"ds-text-heading-display-height-breakpoint-md": "3.75rem",
	"ds-text-heading-display-height-breakpoint-px-md": "60px",
	"ds-text-heading-display-height-breakpoint-lg": "4.25rem",
	"ds-text-heading-display-height-breakpoint-px-lg": "68px",
	"ds-text-body-default-weight": "500",
	"ds-text-body-size-xxs": "0.625rem",
	"ds-text-body-size-xs": "0.75rem",
	"ds-text-body-size-sm": "0.875rem",
	"ds-text-body-size-default": "1rem",
	"ds-text-body-size-lg": "1.125rem",
	"ds-text-body-height-xs": "1rem",
	"ds-text-body-height-sm": "1.25rem",
	"ds-text-body-height-default": "1.5rem",
	"ds-text-body-height-lg": "1.625rem",
	"ds-color-alert-notification-default": "#0074c8",
	"ds-color-alert-warning-default": "#de750c",
	"ds-color-alert-error-default": "#df0b37",
	"ds-color-alert-success-default": "#00805d",
	"ds-color-alert-advisory-default": "#fff0cd",
	"ds-color-alert-bkg-success-default": "#ddf6e8",
	"ds-color-alert-bkg-error-default": "#ffedf1",
	"ds-color-background-primary-100-default": "#ffffff",
	"ds-color-background-primary-100-inverse": "#0e2b4f",
	"ds-color-background-primary-200-default": "#f7f7f7",
	"ds-color-background-primary-200-inverse": "#194069",
	"ds-color-background-primary-300-default": "#e4e8ec",
	"ds-color-background-primary-300-inverse": "#265688",
	"ds-color-background-primary-400-default": "#dddddd",
	"ds-color-background-primary-400-inverse": "#326aa5",
	"ds-color-background-success-default": "#eef8f5",
	"ds-color-background-success-inverse": "#173c30",
	"ds-color-background-error-default": "#fff4f4",
	"ds-color-background-error-inverse": "#74110e",
	"ds-color-background-warning-default": "#fef8e9",
	"ds-color-background-warning-inverse": "#5d4514",
	"ds-color-background-info-default": "#f0f7fd",
	"ds-color-background-info-inverse": "#193d73",
	"ds-color-background-subtle-default": "#f7f8fa",
	"ds-color-background-subtle-inverse": "#2a2a2a",
	"ds-color-background-accent-default": "#ebfafd",
	"ds-color-background-accent-inverse": "#275b72",
	"ds-color-background-emphasis-default": "#c9e0f7",
	"ds-color-background-emphasis-inverse": "#225296",
	"ds-color-background-scrimmed-default": "rgba(0, 0, 0, 0.5)",
	"ds-color-background-lightest": "#ffffff",
	"ds-color-background-lighter": "#f7f7f7",
	"ds-color-background-darker": "#01426a",
	"ds-color-background-darkest": "#00274a",
	"ds-color-background-gradient-default": "linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5))",
	"ds-color-base-white": "#ffffff",
	"ds-color-base-white-100": "rgba(255, 255, 255, 0.03)",
	"ds-color-base-white-200": "rgba(255, 255, 255, 0.06)",
	"ds-color-base-white-300": "rgba(255, 255, 255, 0.12)",
	"ds-color-base-white-400": "rgba(255, 255, 255, 0.25)",
	"ds-color-base-white-500": "rgba(255, 255, 255, 0.5)",
	"ds-color-base-white-opacity-50": "rgba(255, 255, 255, 0.5)",
	"ds-color-base-white-opacity-40": "rgba(255, 255, 255, 0.4)",
	"ds-color-base-white-opacity-0": "rgba(255, 255, 255, 0)",
	"ds-color-base-black": "#000000",
	"ds-color-base-black-100": "rgba(0, 0, 0, 0.03)",
	"ds-color-base-black-200": "rgba(0, 0, 0, 0.06)",
	"ds-color-base-black-300": "rgba(0, 0, 0, 0.12)",
	"ds-color-base-black-400": "rgba(0, 0, 0, 0.25)",
	"ds-color-base-black-500": "rgba(0, 0, 0, 0.5)",
	"ds-color-base-black-opacity-15": "rgba(0, 0, 0, 0.15)",
	"ds-color-base-blue-100": "#f0f7fd",
	"ds-color-base-blue-200": "#c9e0f7",
	"ds-color-base-blue-300": "#a0c9f1",
	"ds-color-base-blue-400": "#79b2ec",
	"ds-color-base-blue-500": "#5398e6",
	"ds-color-base-blue-600": "#3b7fd2",
	"ds-color-base-blue-700": "#2c67b5",
	"ds-color-base-blue-800": "#225296",
	"ds-color-base-blue-900": "#193d73",
	"ds-color-base-blue-1000": "#102a51",
	"ds-color-base-cyan-100": "#ebfafd",
	"ds-color-base-cyan-200": "#a8e9f7",
	"ds-color-base-cyan-300": "#6ad5ef",
	"ds-color-base-cyan-400": "#56bbde",
	"ds-color-base-cyan-500": "#4aa2c7",
	"ds-color-base-cyan-600": "#3e89aa",
	"ds-color-base-cyan-700": "#32718e",
	"ds-color-base-cyan-800": "#275b72",
	"ds-color-base-cyan-900": "#1d4658",
	"ds-color-base-cyan-1000": "#12303d",
	"ds-color-base-error-100": "#fff4f4",
	"ds-color-base-error-200": "#f9aca6",
	"ds-color-base-error-300": "#f16359",
	"ds-color-base-error-400": "#cc1816",
	"ds-color-base-error-500": "#74110e",
	"ds-color-base-gray-100": "#f7f7f7",
	"ds-color-base-gray-200": "#d4ece4",
	"ds-color-base-gray-300": "#c5c5c5",
	"ds-color-base-gray-400": "#adadad",
	"ds-color-base-gray-500": "#959595",
	"ds-color-base-gray-600": "#7e7e7e",
	"ds-color-base-gray-700": "#676767",
	"ds-color-base-gray-800": "#525252",
	"ds-color-base-gray-900": "#3d3d3d",
	"ds-color-base-gray-1000": "#2a2a2a",
	"ds-color-base-green-100": "#f3faf7",
	"ds-color-base-green-200": "#000000",
	"ds-color-base-green-300": "#addbca",
	"ds-color-base-green-400": "#7ec6ac",
	"ds-color-base-green-500": "#51ae8c",
	"ds-color-base-green-600": "#459578",
	"ds-color-base-green-700": "#3a7d64",
	"ds-color-base-green-800": "#306854",
	"ds-color-base-green-900": "#285545",
	"ds-color-base-green-1000": "#1f4436",
	"ds-color-base-lime-100": "#f5fbeb",
	"ds-color-base-lime-200": "#d8efb4",
	"ds-color-base-lime-300": "#badd81",
	"ds-color-base-lime-400": "#a2c270",
	"ds-color-base-lime-500": "#8ca761",
	"ds-color-base-lime-600": "#778f53",
	"ds-color-base-lime-700": "#647845",
	"ds-color-base-lime-800": "#53643a",
	"ds-color-base-lime-900": "#44522f",
	"ds-color-base-lime-1000": "#364126",
	"ds-color-base-navy-100": "#f2f7fb",
	"ds-color-base-navy-200": "#cfe0ef",
	"ds-color-base-navy-300": "#acc9e2",
	"ds-color-base-navy-400": "#89b2d4",
	"ds-color-base-navy-500": "#6899c6",
	"ds-color-base-navy-600": "#4a82b7",
	"ds-color-base-navy-700": "#326aa5",
	"ds-color-base-navy-800": "#265688",
	"ds-color-base-navy-900": "#194069",
	"ds-color-base-navy-1000": "#0e2b4f",
	"ds-color-base-neutral-100": "#f7f8fa",
	"ds-color-base-neutral-200": "#e4e8ec",
	"ds-color-base-neutral-300": "#ccd2db",
	"ds-color-base-neutral-400": "#afb9c6",
	"ds-color-base-neutral-500": "#939fad",
	"ds-color-base-neutral-600": "#7e8894",
	"ds-color-base-neutral-700": "#6a717c",
	"ds-color-base-neutral-800": "#585e67",
	"ds-color-base-neutral-900": "#484d55",
	"ds-color-base-neutral-1000": "#393d43",
	"ds-color-base-pink-100": "#fff7f8",
	"ds-color-base-pink-200": "#fde0e6",
	"ds-color-base-pink-300": "#fcc2ce",
	"ds-color-base-pink-400": "#fa9db0",
	"ds-color-base-pink-500": "#f7738e",
	"ds-color-base-pink-600": "#e45472",
	"ds-color-base-pink-700": "#bf475f",
	"ds-color-base-pink-800": "#a03b50",
	"ds-color-base-pink-900": "#833142",
	"ds-color-base-pink-1000": "#692734",
	"ds-color-base-purple-100": "#fbf8fe",
	"ds-color-base-purple-200": "#ede3fd",
	"ds-color-base-purple-300": "#ddc9fb",
	"ds-color-base-purple-400": "#c9a9f8",
	"ds-color-base-purple-500": "#b588f5",
	"ds-color-base-purple-600": "#a268f3",
	"ds-color-base-purple-700": "#8d47f0",
	"ds-color-base-purple-800": "#7633d7",
	"ds-color-base-purple-900": "#622ab2",
	"ds-color-base-purple-1000": "#4e228d",
	"ds-color-base-red-100": "#fef7f5",
	"ds-color-base-red-200": "#fae2da",
	"ds-color-base-red-300": "#f5c7b8",
	"ds-color-base-red-400": "#f0a68d",
	"ds-color-base-red-500": "#e9815e",
	"ds-color-base-red-600": "#e35c2f",
	"ds-color-base-red-700": "#d03a08",
	"ds-color-base-red-800": "#ae3007",
	"ds-color-base-red-900": "#902806",
	"ds-color-base-red-1000": "#732005",
	"ds-color-base-success-100": "#eef8f5",
	"ds-color-base-success-200": "#8eceb9",
	"ds-color-base-success-300": "#40a080",
	"ds-color-base-success-400": "#0b6f4d",
	"ds-color-base-success-500": "#173c30",
	"ds-color-base-turquoise-100": "#f7fafa",
	"ds-color-base-turquoise-200": "#dfe9ea",
	"ds-color-base-turquoise-300": "#c2d5d6",
	"ds-color-base-turquoise-400": "#9fbdbe",
	"ds-color-base-turquoise-500": "#7ba5a6",
	"ds-color-base-turquoise-600": "#5c8f91",
	"ds-color-base-turquoise-700": "#3d7a7d",
	"ds-color-base-turquoise-800": "#21686a",
	"ds-color-base-turquoise-900": "#085659",
	"ds-color-base-turquoise-1000": "#004447",
	"ds-color-base-yellow-100": "#fff9df",
	"ds-color-base-yellow-200": "#ffe87e",
	"ds-color-base-yellow-300": "#f9ce06",
	"ds-color-base-yellow-400": "#d6b622",
	"ds-color-base-yellow-500": "#b49d35",
	"ds-color-base-yellow-600": "#96873e",
	"ds-color-base-yellow-700": "#7c7140",
	"ds-color-base-yellow-800": "#665e3d",
	"ds-color-base-yellow-900": "#524e38",
	"ds-color-base-yellow-1000": "#403d30",
	"ds-color-base-warning-100": "#fef8e9",
	"ds-color-base-warning-200": "#f2c153",
	"ds-color-base-warning-300": "#c49432",
	"ds-color-base-warning-400": "#8e6b22",
	"ds-color-base-warning-500": "#5d4514",
	"ds-color-state-error-100": "#ff999b",
	"ds-color-state-error-500": "#df0b37",
	"ds-color-state-success-100": "#69cf96",
	"ds-color-state-success-500": "#00805d",
	"ds-color-state-warning-500": "#de750c",
	"ds-color-border-primary-default": "#585e67",
	"ds-color-border-primary-inverse": "#afb9c6",
	"ds-color-border-secondary-default": "#939fad",
	"ds-color-border-secondary-inverse": "#7e8894",
	"ds-color-border-tertiary-default": "#dddddd",
	"ds-color-border-tertiary-inverse": "#676767",
	"ds-color-border-error-default": "#cc1816",
	"ds-color-border-error-inverse": "#f9aca6",
	"ds-color-border-divider-default": "rgba(0, 0, 0, 0.12)",
	"ds-color-border-divider-inverse": "rgba(255, 255, 255, 0.25)",
	"ds-color-border-subtle-default": "#f0f7fd",
	"ds-color-border-subtle-inverse": "#326aa5",
	"ds-color-border-emphasis-default": "#194069",
	"ds-color-border-emphasis-inverse": "#f2f7fb",
	"ds-color-border-accent-default": "#badd81",
	"ds-color-border-accent-inverse": "#a2c270",
	"ds-color-border-success-default": "#0b6f4d",
	"ds-color-border-success-inverse": "#8eceb9",
	"ds-color-border-warning-default": "#c49432",
	"ds-color-border-warning-inverse": "#f2c153",
	"ds-color-border-info-default": "#326aa5",
	"ds-color-border-info-inverse": "#89b2d4",
	"ds-color-border-ui-default-default": "#2c67b5",
	"ds-color-border-ui-default-inverse": "#56bbde",
	"ds-color-border-ui-hover-default": "#193d73",
	"ds-color-border-ui-hover-inverse": "#a8e9f7",
	"ds-color-border-ui-active-default": "#225296",
	"ds-color-border-ui-active-inverse": "#6ad5ef",
	"ds-color-border-ui-focus-default": "#2c67b5",
	"ds-color-border-ui-focus-inverse": "#56bbde",
	"ds-color-border-ui-disabled-default": "#adadad",
	"ds-color-border-ui-disabled-inverse": "#7e7e7e",
	"ds-color-border-active-default": "#0074c8",
	"ds-color-border-active-inverse": "#00cff0",
	"ds-color-border-disabled-default": "#d4ece4",
	"ds-color-border-focus-default": "#959595",
	"ds-color-brand-neutral-100": "#f7f8fa",
	"ds-color-brand-neutral-200": "#e4e8ec",
	"ds-color-brand-neutral-300": "#ccd2db",
	"ds-color-brand-neutral-400": "#afb9c6",
	"ds-color-brand-neutral-500": "#939fad",
	"ds-color-brand-neutral-600": "#7e8894",
	"ds-color-brand-neutral-700": "#6a717c",
	"ds-color-brand-neutral-800": "#585e67",
	"ds-color-brand-neutral-900": "#484d55",
	"ds-color-brand-neutral-1000": "#393d43",
	"ds-color-brand-gray-100": "#f7f7f7",
	"ds-color-brand-gray-200": "#dddddd",
	"ds-color-brand-gray-300": "#c5c5c5",
	"ds-color-brand-gray-400": "#adadad",
	"ds-color-brand-gray-500": "#959595",
	"ds-color-brand-gray-600": "#7e7e7e",
	"ds-color-brand-gray-700": "#676767",
	"ds-color-brand-gray-800": "#525252",
	"ds-color-brand-gray-900": "#3d3d3d",
	"ds-color-brand-gray-1000": "#2a2a2a",
	"ds-color-brand-red-100": "#fef7f5",
	"ds-color-brand-red-200": "#fae2da",
	"ds-color-brand-red-300": "#f5c7b8",
	"ds-color-brand-red-400": "#f0a68d",
	"ds-color-brand-red-500": "#e9815e",
	"ds-color-brand-red-600": "#e35c2f",
	"ds-color-brand-red-700": "#d03a08",
	"ds-color-brand-red-800": "#ae3007",
	"ds-color-brand-red-900": "#902806",
	"ds-color-brand-red-1000": "#732005",
	"ds-color-brand-yellow-100": "#fff9df",
	"ds-color-brand-yellow-200": "#ffe87e",
	"ds-color-brand-yellow-300": "#f9ce06",
	"ds-color-brand-yellow-400": "#d6b622",
	"ds-color-brand-yellow-500": "#b49d35",
	"ds-color-brand-yellow-600": "#96873e",
	"ds-color-brand-yellow-700": "#7c7140",
	"ds-color-brand-yellow-800": "#665e3d",
	"ds-color-brand-yellow-900": "#524e38",
	"ds-color-brand-yellow-1000": "#403d30",
	"ds-color-brand-lime-100": "#f5fbeb",
	"ds-color-brand-lime-200": "#d8efb4",
	"ds-color-brand-lime-300": "#badd81",
	"ds-color-brand-lime-400": "#a2c270",
	"ds-color-brand-lime-500": "#8ca761",
	"ds-color-brand-lime-600": "#778f53",
	"ds-color-brand-lime-700": "#647845",
	"ds-color-brand-lime-800": "#53643a",
	"ds-color-brand-lime-900": "#44522f",
	"ds-color-brand-lime-1000": "#364126",
	"ds-color-brand-green-100": "#f3faf7",
	"ds-color-brand-green-200": "#d4ece4",
	"ds-color-brand-green-300": "#addbca",
	"ds-color-brand-green-400": "#7ec6ac",
	"ds-color-brand-green-500": "#51ae8c",
	"ds-color-brand-green-600": "#459578",
	"ds-color-brand-green-700": "#3a7d64",
	"ds-color-brand-green-800": "#306854",
	"ds-color-brand-green-900": "#285545",
	"ds-color-brand-green-1000": "#1f4436",
	"ds-color-brand-turquoise-100": "#f7fafa",
	"ds-color-brand-turquoise-200": "#dfe9ea",
	"ds-color-brand-turquoise-300": "#c2d5d6",
	"ds-color-brand-turquoise-400": "#9fbdbe",
	"ds-color-brand-turquoise-500": "#7ba5a6",
	"ds-color-brand-turquoise-600": "#5c8f91",
	"ds-color-brand-turquoise-700": "#3d7a7d",
	"ds-color-brand-turquoise-800": "#21686a",
	"ds-color-brand-turquoise-900": "#085659",
	"ds-color-brand-turquoise-1000": "#004447",
	"ds-color-brand-cyan-100": "#ebfafd",
	"ds-color-brand-cyan-200": "#a8e9f7",
	"ds-color-brand-cyan-300": "#6ad5ef",
	"ds-color-brand-cyan-400": "#56bbde",
	"ds-color-brand-cyan-500": "#4aa2c7",
	"ds-color-brand-cyan-600": "#3e89aa",
	"ds-color-brand-cyan-700": "#32718e",
	"ds-color-brand-cyan-800": "#275b72",
	"ds-color-brand-cyan-900": "#1d4658",
	"ds-color-brand-cyan-1000": "#12303d",
	"ds-color-brand-blue-100": "#f0f7fd",
	"ds-color-brand-blue-200": "#c9e0f7",
	"ds-color-brand-blue-300": "#a0c9f1",
	"ds-color-brand-blue-400": "#79b2ec",
	"ds-color-brand-blue-500": "#5398e6",
	"ds-color-brand-blue-600": "#3b7fd2",
	"ds-color-brand-blue-700": "#2c67b5",
	"ds-color-brand-blue-800": "#225296",
	"ds-color-brand-blue-900": "#193d73",
	"ds-color-brand-blue-1000": "#102a51",
	"ds-color-brand-navy-100": "#f2f7fb",
	"ds-color-brand-navy-200": "#cfe0ef",
	"ds-color-brand-navy-300": "#acc9e2",
	"ds-color-brand-navy-400": "#89b2d4",
	"ds-color-brand-navy-500": "#6899c6",
	"ds-color-brand-navy-600": "#4a82b7",
	"ds-color-brand-navy-700": "#326aa5",
	"ds-color-brand-navy-800": "#265688",
	"ds-color-brand-navy-900": "#194069",
	"ds-color-brand-navy-1000": "#0e2b4f",
	"ds-color-brand-purple-100": "#fbf8fe",
	"ds-color-brand-purple-200": "#ede3fd",
	"ds-color-brand-purple-300": "#ddc9fb",
	"ds-color-brand-purple-400": "#c9a9f8",
	"ds-color-brand-purple-500": "#b588f5",
	"ds-color-brand-purple-600": "#a268f3",
	"ds-color-brand-purple-700": "#8d47f0",
	"ds-color-brand-purple-800": "#7633d7",
	"ds-color-brand-purple-900": "#622ab2",
	"ds-color-brand-purple-1000": "#4e228d",
	"ds-color-brand-pink-100": "#fff7f8",
	"ds-color-brand-pink-200": "#fde0e6",
	"ds-color-brand-pink-300": "#fcc2ce",
	"ds-color-brand-pink-400": "#fa9db0",
	"ds-color-brand-pink-500": "#f7738e",
	"ds-color-brand-pink-600": "#e45472",
	"ds-color-brand-pink-700": "#bf475f",
	"ds-color-brand-pink-800": "#a03b50",
	"ds-color-brand-pink-900": "#833142",
	"ds-color-brand-pink-1000": "#692734",
	"ds-color-brand-midnight-100": "#c1daf0",
	"ds-color-brand-midnight-200": "#569ed7",
	"ds-color-brand-midnight-300": "#156fad",
	"ds-color-brand-midnight-400": "#01426a",
	"ds-color-brand-midnight-500": "#00274a",
	"ds-color-brand-atlas-100": "#cde6ff",
	"ds-color-brand-atlas-200": "#6bb7fb",
	"ds-color-brand-atlas-300": "#2492eb",
	"ds-color-brand-atlas-400": "#0074c8",
	"ds-color-brand-atlas-500": "#054687",
	"ds-color-brand-atlas-400-opacity-20": "rgba(0, 116, 200, 0.2)",
	"ds-color-brand-breeze-100": "#c0f7ff",
	"ds-color-brand-breeze-200": "#5de3f7",
	"ds-color-brand-breeze-300": "#00cff0",
	"ds-color-brand-breeze-400": "#099dc5",
	"ds-color-brand-breeze-500": "#0b5575",
	"ds-color-brand-breeze-300-opacity-30": "rgba(0, 207, 240, 0.3)",
	"ds-color-brand-tropical-100": "#e2ffcd",
	"ds-color-brand-tropical-200": "#d0fba6",
	"ds-color-brand-tropical-300": "#c0e585",
	"ds-color-brand-tropical-400": "#91be62",
	"ds-color-brand-tropical-500": "#5e8741",
	"ds-color-brand-alpine-100": "#bcaae6",
	"ds-color-brand-alpine-200": "#9e73ea",
	"ds-color-brand-alpine-300": "#8439ef",
	"ds-color-brand-alpine-400": "#631db8",
	"ds-color-brand-alpine-500": "#39115c",
	"ds-color-brand-flamingo-100": "#ffebee",
	"ds-color-brand-flamingo-200": "#ffc0ca",
	"ds-color-brand-flamingo-300": "#ff94a7",
	"ds-color-brand-flamingo-400": "#f65b7b",
	"ds-color-brand-flamingo-500": "#b82b47",
	"ds-color-brand-canyon-100": "#ffcab6",
	"ds-color-brand-canyon-200": "#f99574",
	"ds-color-brand-canyon-300": "#f26135",
	"ds-color-brand-canyon-400": "#de3e09",
	"ds-color-brand-canyon-500": "#b83302",
	"ds-color-brand-goldcoast-100": "#fff0cd",
	"ds-color-brand-goldcoast-200": "#ffdb67",
	"ds-color-brand-goldcoast-300": "#ffd200",
	"ds-color-brand-goldcoast-400": "#e5ad07",
	"ds-color-brand-goldcoast-500": "#b88624",
	"ds-color-brand-goldgray-100": "#c5c1bf",
	"ds-color-brand-goldgray-200": "#726e6c",
	"ds-color-brand-gold-100": "#ccbc94",
	"ds-color-brand-gold-200": "#7f682e",
	"ds-color-brand-emerald": "#139142",
	"ds-color-brand-sapphire": "#015daa",
	"ds-color-brand-ruby": "#a41d4a",
	"ds-color-brand-lounge": "#01426a",
	"ds-color-brand-loungeplus": "#53b390",
	"ds-color-container-accent-default": "#f5fbeb",
	"ds-color-container-accent-inverse": "#badd81",
	"ds-color-container-emphasis-default": "#ebfafd",
	"ds-color-container-emphasis-inverse": "#6ad5ef",
	"ds-color-container-error-default": "#fff4f4",
	"ds-color-container-error-inverse": "#74110e",
	"ds-color-container-info-default": "#f0f7fd",
	"ds-color-container-info-inverse": "#193d73",
	"ds-color-container-primary-default": "#ffffff",
	"ds-color-container-primary-inverse": "#0e2b4f",
	"ds-color-container-secondary-default": "#f7f7f7",
	"ds-color-container-secondary-inverse": "#194069",
	"ds-color-container-subtle-default": "#f7f8fa",
	"ds-color-container-subtle-inverse": "#393d43",
	"ds-color-container-success-default": "#eef8f5",
	"ds-color-container-success-inverse": "#173c30",
	"ds-color-container-tertiary-default": "rgba(0, 0, 0, 0.03)",
	"ds-color-container-tertiary-inverse": "rgba(255, 255, 255, 0.06)",
	"ds-color-container-warning-default": "#fef8e9",
	"ds-color-container-warning-inverse": "#5d4514",
	"ds-color-container-ui-primary-active-default": "#225296",
	"ds-color-container-ui-primary-active-inverse": "#6ad5ef",
	"ds-color-container-ui-primary-default-default": "#2c67b5",
	"ds-color-container-ui-primary-default-inverse": "#56bbde",
	"ds-color-container-ui-primary-disabled-default": "#a0c9f1",
	"ds-color-container-ui-primary-disabled-inverse": "#275b72",
	"ds-color-container-ui-primary-focus-default": "#2c67b5",
	"ds-color-container-ui-primary-focus-inverse": "#56bbde",
	"ds-color-container-ui-primary-hover-default": "#193d73",
	"ds-color-container-ui-primary-hover-inverse": "#a8e9f7",
	"ds-color-container-ui-secondary-active-default": "#f0f7fd",
	"ds-color-container-ui-secondary-active-inverse": "rgba(255, 255, 255, 0.06)",
	"ds-color-container-ui-secondary-default-default": "#ffffff",
	"ds-color-container-ui-secondary-default-inverse": "rgba(255, 255, 255, 0.03)",
	"ds-color-container-ui-secondary-disabled-default": "#f7f7f7",
	"ds-color-container-ui-secondary-disabled-inverse": "rgba(255, 255, 255, 0.12)",
	"ds-color-container-ui-secondary-focus-default": "#ffffff",
	"ds-color-container-ui-secondary-focus-inverse": "rgba(255, 255, 255, 0.03)",
	"ds-color-container-ui-secondary-hover-default": "rgba(0, 0, 0, 0.03)",
	"ds-color-container-ui-secondary-hover-inverse": "rgba(255, 255, 255, 0.12)",
	"ds-color-container-ui-tertiary-active-default": "rgba(0, 0, 0, 0.06)",
	"ds-color-container-ui-tertiary-active-inverse": "rgba(255, 255, 255, 0.06)",
	"ds-color-container-ui-tertiary-default-default": "rgba(0, 0, 0, 0.03)",
	"ds-color-container-ui-tertiary-default-inverse": "rgba(255, 255, 255, 0.12)",
	"ds-color-container-ui-tertiary-disabled-default": "rgba(0, 0, 0, 0.03)",
	"ds-color-container-ui-tertiary-disabled-inverse": "rgba(255, 255, 255, 0.25)",
	"ds-color-container-ui-tertiary-focus-default": "rgba(0, 0, 0, 0.03)",
	"ds-color-container-ui-tertiary-focus-inverse": "rgba(255, 255, 255, 0.12)",
	"ds-color-container-ui-tertiary-hover-default": "rgba(0, 0, 0, 0.12)",
	"ds-color-container-ui-tertiary-hover-inverse": "rgba(255, 255, 255, 0.25)",
	"ds-color-icon-primary-default": "#676767",
	"ds-color-icon-primary-inverse": "#f7f7f7",
	"ds-color-icon-secondary-default": "#7e8894",
	"ds-color-icon-secondary-inverse": "#ccd2db",
	"ds-color-icon-tertiary-default": "#afb9c6",
	"ds-color-icon-tertiary-inverse": "#939fad",
	"ds-color-icon-emphasis-default": "#2a2a2a",
	"ds-color-icon-emphasis-inverse": "#ffffff",
	"ds-color-icon-accent-default": "#a2c270",
	"ds-color-icon-accent-inverse": "#badd81",
	"ds-color-icon-info-default": "#326aa5",
	"ds-color-icon-info-inverse": "#89b2d4",
	"ds-color-icon-error-default": "#cc1816",
	"ds-color-icon-error-inverse": "#f9aca6",
	"ds-color-icon-warning-default": "#c49432",
	"ds-color-icon-warning-inverse": "#f2c153",
	"ds-color-icon-success-default": "#40a080",
	"ds-color-icon-success-inverse": "#8eceb9",
	"ds-color-icon-subtle-default": "#a0c9f1",
	"ds-color-icon-subtle-inverse": "#326aa5",
	"ds-color-icon-ui-primary-default-default": "#2c67b5",
	"ds-color-icon-ui-primary-default-inverse": "#56bbde",
	"ds-color-icon-ui-primary-hover-default": "#193d73",
	"ds-color-icon-ui-primary-hover-inverse": "#a8e9f7",
	"ds-color-icon-ui-primary-active-default": "#225296",
	"ds-color-icon-ui-primary-active-inverse": "#6ad5ef",
	"ds-color-icon-ui-primary-disabled-default": "#adadad",
	"ds-color-icon-ui-primary-disabled-inverse": "#7e7e7e",
	"ds-color-icon-ui-primary-focus-default": "#2c67b5",
	"ds-color-icon-ui-primary-focus-inverse": "#56bbde",
	"ds-color-icon-ui-secondary-active-default": "#676767",
	"ds-color-icon-ui-secondary-active-inverse": "#c5c5c5",
	"ds-color-icon-ui-secondary-default-default": "#7e7e7e",
	"ds-color-icon-ui-secondary-default-inverse": "#adadad",
	"ds-color-icon-ui-secondary-disabled-default": "#adadad",
	"ds-color-icon-ui-secondary-disabled-inverse": "#7e7e7e",
	"ds-color-icon-ui-secondary-focus-default": "#7e7e7e",
	"ds-color-icon-ui-secondary-focus-inverse": "#adadad",
	"ds-color-icon-ui-secondary-hover-default": "#525252",
	"ds-color-icon-ui-secondary-hover-inverse": "#dddddd",
	"ds-color-icon-brand-red-default": "#d03a08",
	"ds-color-icon-brand-red-inverse": "#e9815e",
	"ds-color-icon-brand-yellow-default": "#7c7140",
	"ds-color-icon-brand-yellow-inverse": "#f9ce06",
	"ds-color-icon-brand-pink-default": "#bf475f",
	"ds-color-icon-brand-pink-inverse": "#f7738e",
	"ds-color-icon-brand-purple-default": "#8d47f0",
	"ds-color-icon-brand-purple-inverse": "#b588f5",
	"ds-color-icon-brand-lime-default": "#647845",
	"ds-color-icon-brand-lime-inverse": "#badd81",
	"ds-color-icon-brand-green-default": "#3a7d64",
	"ds-color-icon-brand-green-inverse": "#51ae8c",
	"ds-color-icon-brand-turquoise-default": "#3d7a7d",
	"ds-color-icon-brand-turquoise-inverse": "#7ba5a6",
	"ds-color-icon-brand-navy-default": "#265688",
	"ds-color-icon-brand-navy-inverse": "#6899c6",
	"ds-color-icon-brand-blue-default": "#2c67b5",
	"ds-color-icon-brand-blue-inverse": "#5398e6",
	"ds-color-icon-brand-cyan-default": "#32718e",
	"ds-color-icon-brand-cyan-inverse": "#6ad5ef",
	"ds-color-icon-brand-gray-default": "#676767",
	"ds-color-icon-brand-gray-inverse": "#c5c5c5",
	"ds-color-icon-brand-neutral-default": "#6a717c",
	"ds-color-icon-brand-neutral-inverse": "#afb9c6",
	"ds-color-icon-disabled-default": "rgba(0, 0, 0, 0.15)",
	"ds-color-text-primary-default": "#2a2a2a",
	"ds-color-text-primary-inverse": "#ffffff",
	"ds-color-text-secondary-default": "#525252",
	"ds-color-text-secondary-inverse": "#dddddd",
	"ds-color-text-tertiary-default": "#6a717c",
	"ds-color-text-tertiary-inverse": "#adadad",
	"ds-color-text-error-default": "#cc1816",
	"ds-color-text-error-inverse": "#f9aca6",
	"ds-color-text-emphasis-default": "#265688",
	"ds-color-text-emphasis-inverse": "#cfe0ef",
	"ds-color-text-accent-default": "#647845",
	"ds-color-text-accent-inverse": "#badd81",
	"ds-color-text-info-default": "#326aa5",
	"ds-color-text-info-inverse": "#acc9e2",
	"ds-color-text-subtle-default": "#32718e",
	"ds-color-text-subtle-inverse": "#56bbde",
	"ds-color-text-success-default": "#0b6f4d",
	"ds-color-text-success-inverse": "#8eceb9",
	"ds-color-text-ui-active-default": "#225296",
	"ds-color-text-ui-active-inverse": "#6ad5ef",
	"ds-color-text-ui-default-default": "#2c67b5",
	"ds-color-text-ui-default-inverse": "#56bbde",
	"ds-color-text-ui-disabled-default": "#adadad",
	"ds-color-text-ui-disabled-inverse": "#7e7e7e",
	"ds-color-text-ui-focus-default": "#2c67b5",
	"ds-color-text-ui-focus-inverse": "#56bbde",
	"ds-color-text-ui-hover-default": "#193d73",
	"ds-color-text-ui-hover-inverse": "#a8e9f7",
	"ds-color-text-link-default": "#0074c8",
	"ds-color-text-link-inverse": "#00cff0",
	"ds-color-tier-alaska-mvp-default": "#726e6c",
	"ds-color-tier-alaska-mvp-inverse": "#c5c1bf",
	"ds-color-tier-alaska-mvpgold-default": "#7f682e",
	"ds-color-tier-alaska-mvpgold-inverse": "#c5c1bf",
	"ds-color-tier-alaska-mvpgold75k-default": "#7f682e",
	"ds-color-tier-alaska-mvpgold75k-inverse": "#c5c1bf",
	"ds-color-tier-alaska-mvpgold100k-default": "#7f682e",
	"ds-color-tier-alaska-mvpgold100k-inverse": "#c5c1bf",
	"ds-color-tier-alaska-lounge": "#01426a",
	"ds-color-tier-alaska-loungeplus": "#53b390",
	"ds-color-tier-fare-business-default": "#005154",
	"ds-color-tier-fare-business-inverse": "#9fbdbe",
	"ds-color-tier-fare-economy-default": "#2c67b5",
	"ds-color-tier-fare-economy-inverse": "#a0c9f1",
	"ds-color-tier-fare-first-class-default": "#002c4e",
	"ds-color-tier-fare-first-class-inverse": "#89b2d4",
	"ds-color-tier-fare-saver-default": "#4aa2c7",
	"ds-color-tier-fare-saver-inverse": "#a8e9f7",
	"ds-color-tier-oneworld-emerald": "#139142",
	"ds-color-tier-oneworld-sapphire": "#015daa",
	"ds-color-tier-oneworld-ruby": "#a41d4a",
	"ds-color-ui-default-default": "#0074c8",
	"ds-color-ui-default-inverse": "#00cff0",
	"ds-color-ui-hover-default": "#054687",
	"ds-color-ui-hover-inverse": "#5de3f7",
	"ds-color-ui-active-default": "#054687",
	"ds-color-ui-active-inverse": "#5de3f7",
	"ds-color-ui-disabled-default": "rgba(0, 116, 200, 0.2)",
	"ds-color-ui-bkg-default-default": "rgba(0, 0, 0, 0.03)",
	"ds-color-ui-bkg-default-inverse": "rgba(255, 255, 255, 0.03)",
	"ds-color-ui-bkg-hover-default": "rgba(0, 0, 0, 0.06)",
	"ds-color-ui-bkg-hover-inverse": "rgba(255, 255, 255, 0.06)",
	"ds-color-utility-blue-default": "#79b2ec",
	"ds-color-utility-blue-inverse": "#c9e0f7",
	"ds-color-utility-cyan-default": "#6ad5ef",
	"ds-color-utility-cyan-inverse": "#a8e9f7",
	"ds-color-utility-green-default": "#7ec6ac",
	"ds-color-utility-green-inverse": "#addbca",
	"ds-color-utility-gray-default": "#adadad",
	"ds-color-utility-gray-inverse": "#dddddd",
	"ds-color-utility-lime-default": "#badd81",
	"ds-color-utility-lime-inverse": "#d8efb4",
	"ds-color-utility-navy-default": "#265688",
	"ds-color-utility-navy-inverse": "#acc9e2",
	"ds-color-utility-neutral-default": "#7e8894",
	"ds-color-utility-neutral-inverse": "#ccd2db",
	"ds-color-utility-pink-default": "#f7738e",
	"ds-color-utility-pink-inverse": "#fcc2ce",
	"ds-color-utility-purple-default": "#8d47f0",
	"ds-color-utility-purple-inverse": "#ddc9fb",
	"ds-color-utility-red-default": "#e35c2f",
	"ds-color-utility-red-inverse": "#f0a68d",
	"ds-color-utility-turquoise-default": "#5c8f91",
	"ds-color-utility-turquoise-inverse": "#9fbdbe",
	"ds-color-utility-yellow-default": "#f9ce06",
	"ds-color-utility-yellow-inverse": "#ffe87e",
	"ds-color-utility-error-default": "#cc1816",
	"ds-color-utility-error-inverse": "#f9aca6",
	"ds-color-utility-warning-default": "#f2c153",
	"ds-color-utility-warning-inverse": "#f2c153",
	"ds-color-utility-success-default": "#0b6f4d",
	"ds-color-utility-success-inverse": "#8eceb9"
};

var styleCss = i$3`.container{display:inline-block;overflow:auto;box-sizing:border-box}:host{position:absolute;z-index:1;display:none}:host([isfullscreen]){position:fixed;top:0;left:0}:host([data-show]){display:block}:host([common]) .container,:host([rounded]) .container{border-radius:var(--ds-border-radius, 0.375rem)}:host([common]) .container,:host([inset]) .container{padding:var(--ds-size-50, 0.25rem) var(--ds-size-100, 0.5rem)}`;

var colorCss = i$3`.container{background-color:var(--ds-auro-dropdownbib-container-color);box-shadow:var(--ds-auro-dropdownbib-boxshadow-color);color:var(--ds-auro-dropdownbib-text-color)}`;

// Copyright (c) 2020 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


/**
 * @attr { Boolean } common - If declared, will apply all styles for the common theme.
 * @attr { Boolean } rounded - If declared, will apply border-radius to the bib.
 * @attr { Boolean } inset - If declared, will apply extra padding to bib content.
 * @csspart bibContainer - Apply css to the bib container.
 */

class AuroDropdownBib extends r {

  static get styles() {
    return [
      styleCss,
      colorCss,
      tokensCss
    ];
  }

  static get properties() {
    return {
      common: {
        type: Boolean,
        reflect: true
      },
      inset: {
        type: Boolean,
        reflect: true
      },
      rounded: {
        type: Boolean,
        reflect: true
      },
      mobileBreakpoint: {
        type: String,
        reflect: false
      }
    };
  }

  // function that renders the HTML and CSS into  the scope of the component
  render() {
    return u$1`
      <div class="container" part="bibContainer">
        <slot></slot>
      </div>
    `;
  }
}

// default internal definition
if (!customElements.get("auro-dropdownbib")) {
  customElements.define("auro-dropdownbib", AuroDropdownBib);
}

// Copyright (c) 2020 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


/**
 * @attr { Boolean } bordered - If declared, applies a border around the trigger slot.
 * @attr { Boolean } common - If declared, the dropdown will be styled with the common theme.
 * @attr { Boolean } chevron - If declared, the dropdown displays an display state chevron on the right.
 * @attr { Boolean } disabled - If declared, the dropdown is not interactive.
 * @attr { Boolean } disableEventShow - If declared, the dropdown will only show by calling the API .show() public method.
 * @attr { Boolean } error - If declared in combination with `bordered` property or `helpText` slot content, will apply red color to both.
 * @attr { Boolean } matchWidth - If declared, the popover and trigger will be set to the same width.
 * @attr { Boolean } inset - If declared, will apply padding around trigger slot content.
 * @attr { Boolean } rounded - If declared, will apply border-radius to trigger and default slots.
 * @attr { Boolean } hoverToggle - if declared, the trigger will toggle the big on mouseover/mouseout.
 * @attr { Boolean } noToggle - If declared, the trigger will only show the the dropdown bib.
 * @attr { Boolean } focusShow - if declared, the the bib will display when focus is applied to the trigger.
 * @attr { Boolean } noHideOnThisFocusLoss - If declared, the dropdown will not hide when moving focus outside the element.
 * @prop { Boolean } isPopoverVisible - If true, the dropdown bib is displayed.
 * @slot - Default slot for the popover content.
 * @slot label - Defines the content of the label.
 * @slot helpText - Defines the content of the helpText.
 * @slot trigger - Defines the content of the trigger.
 * @csspart trigger - The trigger content container.
 * @csspart chevron - The collapsed/expanded state icon container.
 * @csspart helpText - The helpText content container.
 * @csspart popover - The bib content container.
 * @event auroDropdown-triggerClick - Notifies that the trigger has been clicked.
 * @event auroDropdown-ready - Notifies that the component has finished initializing.
 * @event auroDropdown-toggled - Notifies that the visibility of the dropdown bib has changed.
 */
class AuroDropdown extends r {
  constructor() {
    super();

    this.isPopoverVisible = false;
    this.matchWidth = false;
    this.noHideOnThisFocusLoss = false;

    this.privateDefaults();
  }

  /**
   * @private
   * @returns {void} Internal defaults.
   */
  privateDefaults() {
    this.bordered = false;
    this.chevron = false;
    this.disabled = false;
    this.error = false;
    this.inset = false;
    this.placement = 'bottom-start';
    this.rounded = false;
    this.ready = false;
    this.tabIndex = 0;
    this.noToggle = false;

    /**
     * @private
     */
    this.runtimeUtils = new AuroLibraryRuntimeUtils();

    /**
     * @private
     */
    this.floater = new AuroFloatingUI();

    /**
     * @private
     */
    this.floaterConfig = {
      placement: 'bottom-start',
      flip: true,
      autoPlacement: false,
      offset: 0,
    };

    /**
     * Generate unique names for dependency components.
     */
    const versioning = new AuroDependencyVersioning();
    this.iconTag = versioning.generateTag('auro-icon', iconVersion, AuroIcon);
  }

  /**
   * Public method to hide the dropdown.
   * @returns {void}
   */
  hide() {
    this.floater.hideBib();
  }

  /**
   * Public method to show the dropdown.
   * @returns {void}
   */
  show() {
    this.floater.showBib();
  }

  // function to define props used within the scope of this component
  static get properties() {
    return {
      bordered: {
        type: Boolean,
        reflect: true
      },
      chevron: {
        type: Boolean,
        reflect: true
      },
      disabled: {
        type: Boolean,
        reflect: true
      },
      error: {
        type: Boolean,
        reflect: true
      },
      focusShow: {
        type: Boolean,
        reflect: true
      },
      hoverToggle: {
        type: Boolean,
        reflect: true
      },
      inset: {
        type: Boolean,
        reflect: true
      },
      matchWidth: {
        type: Boolean,
        reflect: true
      },
      rounded: {
        type: Boolean,
        reflect: true
      },
      common: {
        type: Boolean,
        reflect: true
      },
      noToggle: {
        type: Boolean,
        reflect: true
      },
      noHideOnThisFocusLoss: {
        type: Boolean,
        reflect: true
      },
      isPopoverVisible: { type: Boolean },
      ready:            { type: Boolean },
      onSlotChange: {
        type: Function,
        reflect: false
      },
      mobileFullscreenBreakpoint: {
        type: String,
        reflect: true,
      },

      /**
       * @private
       */
      dropdownWidth: { type: Number },

      /**
       * @private
       */
      placement:     { type: String },

      /**
       * @private
       */
      tabIndex: { type: Number }
    };
  }

  static get styles() {
    return [
      styleCss$1,
      colorCss$1,
      tokensCss
    ];
  }

  /**
   * This will register this element with the browser.
   * @param {string} [name="auro-dropdown"] - The name of element that you want to register to.
   *
   * @example
   * AuroDropdown.register("custom-dropdown") // this will register this element to <custom-dropdown/>
   *
   */
  static register(name = "auro-dropdown") {
    AuroLibraryRuntimeUtils.prototype.registerComponent(name, AuroDropdown);
  }

  connectedCallback() {
    super.connectedCallback();
  }

  disconnectedCallback() {
    super.disconnectedCallback();
  }

  updated(changedProperties) {
    this.floater.handleUpdate(changedProperties);
  }

  firstUpdated() {
    this.floater.configure(this);
    this.bibContent = this.floater.element.bib;
    if (this.mobileFullscreenBreakpoint) {
      const breakpointValue = dsVariableFlat[this.mobileFullscreenBreakpoint.replace(/^\-\-/, "")];
      this.bibContent.mobileFullscreenBreakpoint = breakpointValue;
    }

    // Add the tag name as an attribute if it is different than the component name
    this.runtimeUtils.handleComponentTagRename(this, 'auro-dropdown');

    this.notifyReady();
  }

  /**
   * Marks the component as ready and sends event.
   * @private
   * @returns {void}
   */
  notifyReady() {
    this.ready = true;

    this.dispatchEvent(new CustomEvent('auroDropdown-ready', {
      bubbles: true,
      cancelable: false,
      composed: true,
    }));
  }

  /**
   * Exposes CSS parts for styling from parent components.
   * @private
   * @returns {void}
   */
  exposeCssParts() {
    this.setAttribute('exportparts', 'trigger:dropdownTrigger, chevron:dropdownChevron, helpText:dropdownHelpText, popover:dropdownPopover');
  }

  /**
   * Determines if content is within a custom slot.
   * @private
   * @param {HTMLElement} element - The element to check.
   * @returns {Boolean}
   */
  isCustomSlotContent(element) {
    let currentElement = element;

    let inCustomSlot = false;

    while (currentElement) {
      currentElement = currentElement.parentElement;

      if (currentElement && currentElement.hasAttribute('slot')) {
        inCustomSlot = true;
      }
    }

    return inCustomSlot;
  }

  /**
   * Handles the default slot content.
   * @private
   * @returns {void}
   */
  handleDefaultSlot() {
    const allSlotContent = Array.from(this.childNodes).filter((node) => {
      // Include text nodes and elements without a slot attribute
      return node.nodeType === Node.TEXT_NODE || (node.nodeType === Node.ELEMENT_NODE && !node.hasAttribute('slot'));
    });

    this.defaultSlotContent = [];

    allSlotContent.forEach((item) => {
      if (!this.isCustomSlotContent(item)) {
        this.defaultSlotContent.push(item);
      }
    });

    this.defaultSlotContent.forEach((item) => {
      this.bibContent.append(item);
    });

    if (this.onSlotChange) {
      this.onSlotChange();
    }
  }

  // function that renders the HTML and CSS into  the scope of the component
  render() {
    return u$1`
      <div>
        <div
          id="trigger"
          class="trigger"
          part="trigger"
          role="button"
          aria-labelledby="triggerLabel"
          aria-controls="popover"
          tabindex="${this.tabIndex}"
          >
          <div class="triggerContentWrapper">
            <label class="label" id="triggerLabel">
              <slot name="label"></slot>
            </label>
            <div class="triggerContent">
              <slot
                name="trigger"
                @slotchange="${() => {if (this.ready) this.floater.handleTriggerTabIndex(); }}"></slot>
            </div>
          </div>
          ${this.chevron || this.common ? u$1`
              <div
                id="showStateIcon"
                part="chevron">
                <${this.iconTag}
                  category="interface"
                  name="chevron-down"
                  customColor
                  ?disabled=${this.disabled}
                  >
                </${this.iconTag}>
              </div>
            ` : undefined }
        </div>
        <div
          class="helpText"
          part="helpText">
          <slot name="helpText"></slot>
        </div>
        <div class="slotContent">
          <slot @slotchange="${this.handleDefaultSlot}"></slot>
        </div>
        <div id="bibSizer" part="bibSizer" style="position: absolute; pointer-events: none; opacity: 0; z-index: -1;"></div>
        <auro-dropdownbib
          id="bib"
          role="tooltip"
          ?common="${this.common}"
          ?rounded="${this.common || this.rounded}"
          ?inset="${this.common || this.inset}">
        </auro-dropdownbib>
      </div>
    `;
  }
}

AuroDropdown.register();

/* eslint-disable jsdoc/require-jsdoc, no-magic-numbers */

function initExamples(initialCount = 0) {
  try {
    // javascript example function calls to be added here upon creation to test examples
    showExample();
    hideExample();
  } catch (err) {
    if (initialCount <= 20) {
      // setTimeout handles issue where content is sometimes loaded after the functions get called
      setTimeout(() => {
        initExamples(initialCount + 1);
      }, 100);
    }
  }
}

export { initExamples };
